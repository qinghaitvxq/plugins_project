/*
* The MIT License (MIT)
*
* Copyright (c) 2015 Benedikt Schmitt <benedikt@benediktschmitt.de>
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

"use strict";


var jQuery = jQuery || require("jquery");


(function(){
	/*
	* Special classes:
	*
	*	* node-tree
	*
	* 	* node-not-loaded
	* 	* node-loading
	* 	* node-loaded
	*
	* 	* node-empty
	* 	* node-not-empty
	*
	*	* node-body
	* 	* node-children
	*
	* 	* node-collapsed
	* 	* node-expanded
	*
	* Data attributes:
	*
	* 	* data-expand=node
	*	* data-collapse=node
	* 	* data-select=node
	*
	* Input elements:
	*
	*	When the dom element *elem* contains an input field, its value will be
	* 	automatically updated to the id of the currently selected node.
	*
	* The tree view is very lazy. All nodes are only loaded, when they are
	* visible.
	*/
	var TreeView = function(elem, options){
		/*
		* We insert the ``<div class"=node-tree"><div>`` in this element.
		*/
		var dom = jQuery(elem);

		// Reference for later in nested functions.
		var tree_view = this;


		// Model
		// *****

		var model = {};
		model["node_id"] = options.node_id;
		model["root_node"] = options.root_node;
		model["child_nodes"] = options.child_nodes;
		model["parent_node"] = options.parent_node;

		/*
		* This function is derived from *node_id()* and *parent_node()*.
		*
		* It returns all parents of the node with the id *node_id* in a list,
		* starting with the root node.
		*
		* Arguments:
		*
		*	* node_id
		*
		* Returns:
		*
		*	jQuery.Deferred()
		*/
		model["parent_nodes"] = function(node_id){
			var def = jQuery.Deferred();
			var parents = [];

			/*
			* Collect all parents recursive, until we reach the root node.
			*/
			var collect_parent = function(node_id){
				model.parent_node(node_id).done(function(parent){
					if(parent){
						parents.unshift(parent);

						var parent_id = model.node_id(parent);
						collect_parent(parent_id);
					}
					else{
						def.resolve(parents);
					}
				});
			};
			collect_parent(node_id);

			return def;
		};


		// View
		// ****

		/*
		* Renders a node and returns the html.
		*
		* Arguments:
		*
		*	* node_id
		* 	* node
		*
		* Returns:
		*
		*	html (str)
		*/
		var render_node = options.render_node;


		/*
		* Arguments:
		*
		*	* node
		*	* [parent_id]
		*		MUST only be omitted for the root node.
		*/
		var insert_node = function(node, parent_id){
			var node_id = model.node_id(node);

			/*
			* Get the parent of the folder in the tree view, so that we can
			* add the folder to the parents subfolder list.
			*/
			if(parent_id === undefined){
				var dom_node_children = dom.find(".node-tree");
			}
			else{
				var dom_node_children = dom.find(
					".node[data-node=" + parent_id + "]"
				).children(
					".node-children"
				);
			}

			// Insert the dom element for the node and set it up.

			var html = render_node(node_id, node);
			dom_node_children.append(html);

			var dom_node = dom.find(".node[data-node=" + node_id + "]");

			dom_node.children(".node-body").find(".node-loading").hide();
			dom_node.children(".node-body").find(".node-loaded").hide();
			dom_node.children(".node-body").find(".node-not-loaded").show();

			dom_node.children(".node-body").find(".node-empty").hide();
			dom_node.children(".node-body").find(".node-not-empty").hide();

			dom_node.children(".node-children").hide();

			dom_node.children(".node-body").find(".node-expanded").hide();
			dom_node.children(".node-body").find(".node-collapsed").hide();

			// Register some events.

			dom_node.find("[data-collapse=node]").click(function(event){
				var node = jQuery(event.target).closest(".node");
				var node_id = node.data("node");
				tree_view.collapse(node_id);
			});

			dom_node.find("[data-expand=node]").click(function(event){
				var node = jQuery(event.target).closest(".node");
				var node_id = node.data("node");
				tree_view.expand(node_id);
			});

			dom_node.find("[data-select=node]").click(function(event){
				var node = jQuery(event.target).closest(".node");
				var node_id = node.data("node");
				tree_view.select(node_id);
			});
		};


		/*
		* Loads the node from the server/model and inserts them into the dom.
		*
		* Returns:
		*
		*	jQuery.Deferred()
		*/
		var loading_defs = {};
		var load_node = function(node_id){
			// Check if we are alreading loading the children.
			// This check is used to avoid loading the children multiple times
			// from the server, if the user can't stop clicking.
			var def = loading_defs[node_id];
			if(def)
			{
				return def;
			}
			def = loading_defs[node_id] = jQuery.Deferred();


			var dom_node = dom.find(".node[data-node=" + node_id + "]");

			dom_node.children(".node-body").find(".node-not-loaded").hide();
			dom_node.children(".node-body").find(".node-loaded").hide();
			dom_node.children(".node-body").find(".node-loading").show();

			model.child_nodes(node_id).done(function(children){
				dom_node.children(".node-body").find(".node-not-loaded").hide();
				dom_node.children(".node-body").find(".node-loading").hide();
				dom_node.children(".node-body").find(".node-loaded").show();

				if(!jQuery.isEmptyObject(children)){
					dom_node.children(".node-body").find(".node-empty").hide();
					dom_node.children(".node-body").find(".node-not-empty").show();
				}
				else{
					dom_node.children(".node-body").find(".node-not-empty").hide();
					dom_node.children(".node-body").find(".node-empty").show();
				}

				dom_node.children(".node-children").hide();
				dom_node.children(".node-body").find(".node-expanded").hide();
				dom_node.children(".node-body").find(".node-collapsed").show();

				for(var i = 0; i < children.length; i++){
					var child = children[i];
					insert_node(child, node_id);
				}

				def.resolve();
			}).fail(function(){
				dom_node.children(".node-body").find(".node-loaded").hide();
				dom_node.children(".node-body").find(".node-loading").hide();
				dom_node.children(".node-body").find(".node-not-loaded").show();

				def.reject();
			});

			return def;
		};

		/*
		* Removes all **children** of the node with the id *node_id* from the
		* view.
		* When the node is loaded the next time using load_node(), the children
		* will be loaded again from the model/server.
		*
		* Arguments:
		*
		*	* node_id
		*/
		this.unload_node = function(node_id){
			delete loading_defs[node_id];

			var dom_node = dom.find(".node[data-node=" + node_id + "]");
			dom_node.children(".node-children").empty();

			dom_node.children(".node-body").find(".node-loading").hide();
			dom_node.children(".node-body").find(".node-loaded").hide();
			dom_node.children(".node-body").find(".node-not-loaded").show();

			dom_node.children(".node-body").find(".node-empty").hide();
			dom_node.children(".node-body").find(".node-not-empty").hide();

			dom_node.children(".node-children").hide();

			dom_node.children(".node-body").find(".node-expanded").hide();
			dom_node.children(".node-body").find(".node-collapsed").hide();
		};


		/*
		* Hides all children.
		*
		* Arguments:
		*
		*	* node_id
		*/
		this.collapse = function(node_id){
			var dom_node = dom.find(".node[data-node=" + node_id + "]");
			dom_node.children(".node-children").hide();
			dom_node.children(".node-body").find(".node-expanded").hide();
			dom_node.children(".node-body").find(".node-collapsed").show();
		};


		/*
		* Hides all children (subtrees), so that only the root node is visible.
		*
		* Please note, that this is NOT equal to call collapse(root_node_id).
		*/
		this.collapse_all = function(){
			dom.find(".node-children").hide();
			dom.find(".node-expanded").hide();
			dom.find(".node-collapsed").show();
		};


		/*
		* Shows the children of the node with the id *node_id*. If the node
		* has not been loaded yet, it is done now.
		*
		* Returns:
		*
		*	* jQuery.Deferred()
		*
		* Arguments:
		*
		*	* node_id
		*/
		this.expand = function(node_id){
			var def = jQuery.Deferred();

			load_node(node_id).done(function(){
				var dom_node = dom.find(".node[data-node=" + node_id + "]");
				dom_node.children(".node-body").find(".node-collapsed").hide();
				dom_node.children(".node-body").find(".node-expanded").show();
				dom_node.children(".node-children").show();

				def.resolve();
			}).fail(function(){
				def.reject();
			});

			return def;
		};


		/*
		* Expands all parent nodes of the node with the id *node_id*. The node
		* itself is not expanded.
		*
		* If some nodes have not been loaded yet, it is done now.
		*
		* Returns:
		*
		*	* jQuery.Deferred()
		*
		* Arguments:
		*
		*	* node_id
		*/
		this.expand_to = function(node_id){
			var def = jQuery.Deferred();

			model.parent_nodes(node_id).done(function(parents){
				// Expands all nodes recursively.
				var expand_recursive = function(nodes){
					if(nodes.length == 0){
						def.resolve();
						return;
					}

					var node = nodes[0];
					nodes.shift();

					tree_view.expand(node.id).done(function(){
						expand_recursive(nodes);
					}).fail(function(){
						def.reject();
					});
				};

				expand_recursive(parents);
			}).fail(function(){
				def.reject();
			});

			return def;
		};


		/*
		* Selectes the node with the id *node_id* as active. If the view widget
		* contains an input element, the value of that input element is set to the
		* node's id.
		*
		* See also:
		*
		*	* expand_to()
		*
		* Arguments:
		*
		* 	* node_id
		*/
		this.select = function(node_id){
			this.expand_to(node_id).done(function(){
				// Remove the selection from the old node.
				dom.find(".node.active").removeClass("active");

				// Mark the new node as selected.
				dom.find(".node[data-node=" + node_id + "]").addClass("active");

				// Update the input element.
				dom.find("input").val(node_id);
			});
		};


		/*
		* Returns:
		*
		*	The id of the currently selected node.
		*/
		this.selection = function(){
			return dom.find("input").val();
		};


		// Init
		// ****

		(function(){
			if(dom.find(".node-tree").size() == 0)
			{
				dom.append("<div class='node-tree'></div>");
			}

			dom.find("input").change(function(){
				var node_id = tree_view.selection();
				tree_view.collapse_all();
				tree_view.select(node_id);
			});

			model.root_node().done(function(root_node){
				insert_node(root_node);
				tree_view.select(tree_view.selection());
			});
		})();
	};


	/*
	* The actual jQuery plugin. It makes also sure, that a tree view is
	* never initialised two times.
	*
	* Methods:
	*
	*	* treeView("init", options)
	*
	*		Initialises the tree view widget, if not yet done.
	*
	*		options:
	*			{
	*				node_id: function(node),
	*				root_node: function(),
	*				child_nodes: function(node_id),
	*				parent_nodes: function(node_id),
	*				render_node: function(node_id, node)
	*			}
	*
	*	* treeView("collapse", node_id)
	*
	*		Hides the children of the node.
	*
	*	* treeView("collapse_all")
	*
	*		Hides the children of each node, leaving only the root node visible.
	*
	*	* treeView("unload_node", node_id)
	*
	*		Removes the children of the node in the view, so that the node is
	*		reloaded the next time it is expanded.
	*
	*	* treeView("expand", node_id)
	*
	*		Shows the direct children of the node. If not yet done, the children
	*		are loaded from the model.
	*
	*	* treeView("expand_to", node_id)
	*
	*		Shows all parents of the node.
	*
	*	* treeView("select", node_id)
	*
	*		Selects the node with this id. This changes the input value of
	*		any input field in the treeview, to *node_id*.
	*
	*	* treeView("selection")
	*
	*		Returns the id of the selected node. The treeview must have an
	*		input element when you need to use this method.
	*/
	jQuery.fn.treeView = function(method, options){
		this.each(function(){
			var tree_view = jQuery.data(this, "treeView");

			if(method == "init" && !tree_view){
				tree_view = new TreeView(this, options);
				jQuery.data(this, "treeView", tree_view);
			}
			else if(method == "collapse"){
				tree_view.collapse(options);
			}
			else if(method == "collapse_all"){
				tree_view.collapse_all();
			}
			else if(method == "unload_node"){
				tree_view.unload_node(options);
			}
			else if(method == "expand"){
				tree_view.expand(options);
			}
			else if(method == "expand_to"){
				tree_view.expand_to(options);
			}
			else if(method == "select"){
				tree_view.select(options);
			}
			else if(method == "selection"){
				tree_view.selection();
			}
		});
		return this;
	};
})();
